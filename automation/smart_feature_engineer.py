from __future__ import annotations

from typing import List, Dict, Any

import pandas as pd

__all__ = ["suggest_intelligent_features"]


def suggest_intelligent_features(
    df: pd.DataFrame, target: str, profile: Dict[str, Any] | None
) -> List[Dict[str, str]]:
    """Return heuristic feature suggestions based on dataset profile.

    Parameters
    ----------
    df:
        Input dataframe.
    target:
        Name of the target column.
    profile:
        Optional dataset profile generated by
        :class:`EnhancedDatasetProfiler`.

    Returns
    -------
    List[Dict[str, str]]
        Proposed features with keys ``name``, ``formula`` and ``rationale``.
    """
    if profile is None:
        profile = {}

    suggestions: List[Dict[str, str]] = []

    # --- Temporal feature extraction ---
    semantics = profile.get("domain_insights", {}).get("column_semantics", {})
    for col, sem in semantics.items():
        if sem == "datetime" and col != target:
            base = f"pd.to_datetime({col})"
            suggestions.append(
                {
                    "name": f"{col}_year",
                    "formula": f"{base}.dt.year",
                    "rationale": f"Year extracted from {col} may capture seasonality",
                }
            )
            suggestions.append(
                {
                    "name": f"{col}_month",
                    "formula": f"{base}.dt.month",
                    "rationale": f"Month extracted from {col} may reveal cyclical patterns",
                }
            )
            suggestions.append(
                {
                    "name": f"{col}_dayofweek",
                    "formula": f"{base}.dt.dayofweek",
                    "rationale": f"Day of week from {col} can encode weekly trends",
                }
            )
            suggestions.append(
                {
                    "name": f"{col}_hour",
                    "formula": f"{base}.dt.hour",
                    "rationale": f"Hour from {col} may capture time-of-day effects",
                }
            )

    # --- Interaction terms for highly correlated pairs ---
    corr = profile.get("correlations") or {}
    corr_df = pd.DataFrame(corr)
    if not corr_df.empty:
        numeric_cols = [c for c in corr_df.columns if c != target]
        for i, c1 in enumerate(numeric_cols):
            for c2 in numeric_cols[i + 1 :]:
                try:
                    coef = float(corr_df.loc[c1, c2])
                except Exception:
                    try:
                        coef = float(corr_df.loc[c2, c1])
                    except Exception:
                        continue
                if abs(coef) >= 0.7:
                    suggestions.append(
                        {
                            "name": f"{c1}_x_{c2}",
                            "formula": f"{c1} * {c2}",
                            "rationale": f"Interaction between correlated {c1} and {c2}",
                        }
                    )

    # --- Polynomial features for small numeric sets ---
    numeric_cols = [col for col in df.select_dtypes(include="number").columns if col != target]
    if len(numeric_cols) <= 5:
        for col in numeric_cols:
            suggestions.append(
                {
                    "name": f"{col}_squared",
                    "formula": f"{col} ** 2",
                    "rationale": f"Square of {col} may capture nonlinearity",
                }
            )
            suggestions.append(
                {
                    "name": f"{col}_cubed",
                    "formula": f"{col} ** 3",
                    "rationale": f"Cube of {col} may capture higher-order effect",
                }
            )

    # Remove duplicates while preserving order
    seen = set()
    unique: List[Dict[str, str]] = []
    for s in suggestions:
        name = s.get("name")
        if name and name not in seen:
            seen.add(name)
            unique.append(s)
    return unique
